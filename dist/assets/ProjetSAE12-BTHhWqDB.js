import{j as e}from"./index-sUHI6zVS.js";import{P as i}from"./ProjectPagination-DXMRWUZK.js";const s=()=>e.jsxs(e.Fragment,{children:[e.jsxs("section",{id:"project-detail",children:[e.jsx("h2",{children:"Description"}),e.jsxs("p",{children:["Ce projet, intitule ",e.jsx("strong",{children:'"Classification automatique"'}),", visait a ameliorer un systeme de tri de depeches d'actualite en developpant une methode de generation automatique de lexiques. Contrairement a la premiere partie ou les lexiques etaient manuels, nous avons ici experimente l'apprentissage automatique afin de generer des lexiques plus pertinents et d'ameliorer la precision du systeme de classification. Binome : Paolo Colombat, Enzo Morello."]})]}),e.jsxs("section",{id:"skills",children:[e.jsx("h2",{children:"Competences"}),e.jsxs("ul",{children:[e.jsx("li",{children:"Manipulation de structures de donnees en Java (ArrayList, objets personnalises)"}),e.jsx("li",{children:"Analyse de texte et traitement de chaines"}),e.jsx("li",{children:"Ecriture et lecture de fichiers"}),e.jsx("li",{children:"Conception d'algorithmes de ponderation"}),e.jsx("li",{children:"Comparaison experimentale de methodes d'IA"})]})]}),e.jsxs("section",{id:"techniques",children:[e.jsx("h2",{children:"Competences Techniques & Savoir-Faire"}),e.jsxs("ul",{children:[e.jsx("li",{children:"Utilisation de Java pour la classification textuelle"}),e.jsx("li",{children:"Utilisation d'IntelliJ comme IDE"}),e.jsx("li",{children:"Application d'heuristiques pour ponderer les lexiques"}),e.jsx("li",{children:"Optimisation par tri et recherche dichotomique"}),e.jsx("li",{children:"Comparaison avec la methode K-NN simplifiee"})]})]}),e.jsxs("section",{id:"objectives",children:[e.jsx("h2",{children:"Objectifs"}),e.jsxs("ul",{children:[e.jsx("li",{children:"Automatiser la generation de lexiques a partir de depeches categorisees"}),e.jsx("li",{children:"Calculer un score pour chaque mot en fonction de sa frequence et specificite"}),e.jsx("li",{children:"Attribuer des poids aux mots selon leur pertinence"}),e.jsx("li",{children:"Evaluer les performances du systeme avec ces lexiques sur des donnees de test"}),e.jsx("li",{children:"Comparer avec la methode des K plus proches voisins"})]})]}),e.jsxs("section",{id:"group-work",children:[e.jsx("h2",{children:"Travail en groupe"}),e.jsx("p",{children:"Le projet a ete realise en binome. Nous avons reparti les taches comme suit : l'un travaillait principalement sur les algorithmes de traitement de texte et de calcul de scores, tandis que l'autre gerait la structure du code, les tests et les comparaisons de methodes. Nous avons effectue une relecture mutuelle avant chaque etape importante. Je me suis occupe principalement de la premiere partie et sur ce qui demandait le plus de travail \"iteratif\" (augmenter empiriquement un score). Notamment, mon camarade a passe beaucoup de temps sur la methode KNN (discutablement la plus difficile) et a pu me l'expliquer apres."})]}),e.jsxs("section",{id:"individual-work",children:[e.jsx("h2",{children:"Travail individuel"}),e.jsxs("p",{children:["Personnellement, j'ai implemente plusieurs methodes ",e.jsx("code",{children:"initDico"}),",",e.jsx("code",{children:"calculScores"})," et ",e.jsx("code",{children:"poidsPourScore"}),", tout en documentant clairement les choix algorithmiques faits pour le calcul des scores et l'attribution des poids. J'ai aussi participe a l'ecriture du rapport en anglais et a la preparation de la presentation orale."]})]}),e.jsx(i,{currentPath:"/projet-SAE12"})]});export{s as default};
